// src/codegen.rs

use crate::ast::*;
use std::collections::HashMap;

pub struct CodeGenerator {
    // Simula i parametri di configurazione importati
    config: HashMap<String, bool>,
    indent_level: usize,
    output: String,
}

impl CodeGenerator {
    pub fn new() -> Self {
        // Per il prototipo, hardcodiamo la configurazione
        let mut config = HashMap::new();
        config.insert("INCLUDE_LOGIC_OPS".to_string(), true);
        config.insert("INCLUDE_SHIFTER".to_string(), false);

        CodeGenerator {
            config,
            indent_level: 0,
            output: String::new(),
        }
    }

    // Funzione principale per generare l'output
    pub fn generate(&mut self, module: &Module) -> String {
        self.emit("// Auto-generated by veridec v0.1\n");
        self.generate_module(module);
        self.output.clone()
    }
    
    fn indent(&mut self) { self.indent_level += 1; }
    fn dedent(&mut self) { self.indent_level -= 1; }
    fn emit(&mut self, s: &str) {
        if s.ends_with("endmodule") || s.ends_with("end") {
            self.dedent();
        }
        for _ in 0..self.indent_level { self.output.push_str("  "); }
        self.output.push_str(s);
        self.output.push('\n');
        if s.starts_with("module") || s.starts_with("begin") {
            self.indent();
        }
    }

    fn generate_expr(&self, expr: &Expr) -> String {
        match expr {
            Expr::Identifier(s) => s.clone(),
            Expr::Literal(s) => s.clone(),
            Expr::BinaryOp(l, op, r) => {
                let op_str = match op {
                    Op::Plus => "+", Op::Minus => "-",
                    Op::BitAnd => "&", Op::BitOr => "|",
                };
                format!("{} {} {}", self.generate_expr(l), op_str, self.generate_expr(r))
            }
        }
    }

    fn generate_module(&mut self, module: &Module) {
        let ports: Vec<_> = module.declarations.iter().filter_map(|d| match d {
            Declaration::Port{..} => Some(d),
            _ => None
        }).collect();

        // Dichiarazione porte
        let mut port_list = String::new();
        for (i, p) in ports.iter().enumerate() {
            if let Declaration::Port { direction, is_reg, name, width } = p {
                let dir_str = match direction { PortDirection::Input => "input", PortDirection::Output => "output" };
                let reg_str = if *is_reg { "reg " } else { "" };
                let width_str = if *width > 1 { format!("[{}:0] ", *width - 1) } else { "".to_string() };
                port_list.push_str(&format!("  {} {}{}{}", dir_str, reg_str, width_str, name));
                if i < ports.len() - 1 { port_list.push_str(",\n"); }
            }
        }
        self.emit(&format!("module {}(\n{}\n);", module.name, port_list));

        // Corpo del modulo
        for decl in &module.declarations {
            self.generate_declaration(decl);
        }

        self.emit("endmodule");
    }

    fn generate_declaration(&mut self, decl: &Declaration) {
        match decl {
            Declaration::Port {..} => {}, // Già gestite
            Declaration::Combinatorial(stmts) => {
                self.emit("always @(*) begin");
                for stmt in stmts { self.generate_statement(stmt); }
                self.emit("end");
            }
            Declaration::ConditionalBlock { condition, declarations } => {
                // Ecco la magia della generazione!
                if *self.config.get(condition).unwrap_or(&false) {
                    for d in declarations {
                        self.generate_declaration(d);
                    }
                }
            }
        }
    }

    fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Assignment { target, expr } => {
                self.emit(&format!("{} = {};", target, self.generate_expr(expr)));
            },
            Statement::Switch { switch_expr, cases, default } => {
                // Se è un blocco "fittizio" da un gen if, stampiamo solo i case
                if let Expr::Identifier(s) = switch_expr {
                    if s.is_empty() {
                         for (case_expr, case_stmt) in cases {
                            self.emit(&format!("case ({}):", self.generate_expr(case_expr)));
                            self.generate_statement(case_stmt);
                        }
                        return;
                    }
                }
                
                self.emit(&format!("case ({})", self.generate_expr(switch_expr)));
                self.indent();
                for (case_expr, case_stmt) in cases {
                     self.emit(&format!("{}:", self.generate_expr(case_expr)));
                     self.indent();
                     self.generate_statement(case_stmt);
                     self.dedent();
                }
                if let Some(def_stmt) = default {
                    self.emit("default:");
                    self.indent();
                    self.generate_statement(def_stmt);
                    self.dedent();
                }
                self.dedent();
                self.emit("endcase");
            }
        }
    }
}